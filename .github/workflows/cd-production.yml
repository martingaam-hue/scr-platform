name: Deploy — Production

on:
  # Manual trigger only (or tag push for automated releases)
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Git SHA or tag to deploy (defaults to latest main)"
        required: false
        default: ""
      confirm:
        description: "Type DEPLOY to confirm production deployment"
        required: true
  push:
    tags:
      - "v[0-9]+.[0-9]+.[0-9]+"

concurrency:
  group: deploy-production
  cancel-in-progress: false

env:
  AWS_REGION: eu-west-1
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  ECS_CLUSTER: scr-production
  IMAGE_TAG: ${{ github.event.inputs.image_tag || github.sha }}

jobs:
  # ── Guard: require confirmation on manual trigger ─────────────────────────────
  confirm:
    name: Confirm deployment
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
      - name: Check confirmation
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "DEPLOY" ]; then
            echo "❌ Deployment not confirmed. Type DEPLOY in the confirm field."
            exit 1
          fi
          echo "✓ Deployment confirmed"

  # ── Promote staging images to production tags ─────────────────────────────────
  promote-images:
    name: Promote images to production
    runs-on: ubuntu-latest
    needs: [confirm]
    if: always() && (needs.confirm.result == 'success' || github.event_name == 'push')
    environment: production

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Re-tag images for production
        run: |
          for SERVICE in scr-api scr-web scr-ai-gateway; do
            echo "Tagging $SERVICE:${{ env.IMAGE_TAG }} → production-latest"

            # Pull manifest from staging tag, re-tag as production-latest
            docker pull ${{ env.ECR_REGISTRY }}/$SERVICE:${{ env.IMAGE_TAG }}
            docker tag  ${{ env.ECR_REGISTRY }}/$SERVICE:${{ env.IMAGE_TAG }} \
                        ${{ env.ECR_REGISTRY }}/$SERVICE:production-latest
            docker push ${{ env.ECR_REGISTRY }}/$SERVICE:production-latest

            echo "✓ $SERVICE promoted"
          done

  # ── Database migrations ───────────────────────────────────────────────────────
  migrate:
    name: Run DB migrations
    runs-on: ubuntu-latest
    needs: [promote-images]
    environment: production

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Run Alembic upgrade via ECS task
        run: |
          TASK_ARN=$(aws ecs run-task \
            --cluster ${{ env.ECS_CLUSTER }} \
            --task-definition scr-api-migrate-production \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${{ secrets.PROD_PRIVATE_SUBNET_IDS }}],securityGroups=[${{ secrets.PROD_ECS_SG_ID }}]}" \
            --overrides '{"containerOverrides":[{"name":"api","command":["poetry","run","alembic","upgrade","head"]}]}' \
            --query 'tasks[0].taskArn' \
            --output text)

          echo "Migration task: $TASK_ARN"
          aws ecs wait tasks-stopped \
            --cluster ${{ env.ECS_CLUSTER }} \
            --tasks "$TASK_ARN"

          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --tasks "$TASK_ARN" \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)

          if [ "$EXIT_CODE" != "0" ]; then
            echo "❌ Migration failed (exit $EXIT_CODE). Aborting deployment."
            exit 1
          fi

          echo "✓ Migrations applied"

  # ── Deploy services ───────────────────────────────────────────────────────────
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [promote-images, migrate]
    environment: production

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.IMAGE_TAG }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update API task definition
        id: api-taskdef
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: .github/ecs/production-api-taskdef.json
          container-name: api
          image: ${{ env.ECR_REGISTRY }}/scr-api:${{ env.IMAGE_TAG }}

      - name: Deploy API (rolling update)
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.api-taskdef.outputs.task-definition }}
          service: scr-api-production
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true
          wait-for-minutes: 15

      - name: Update Gateway task definition
        id: gateway-taskdef
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: .github/ecs/production-gateway-taskdef.json
          container-name: ai-gateway
          image: ${{ env.ECR_REGISTRY }}/scr-ai-gateway:${{ env.IMAGE_TAG }}

      - name: Deploy Gateway
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.gateway-taskdef.outputs.task-definition }}
          service: scr-ai-gateway-production
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: Update Web task definition
        id: web-taskdef
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: .github/ecs/production-web-taskdef.json
          container-name: web
          image: ${{ env.ECR_REGISTRY }}/scr-web:${{ env.IMAGE_TAG }}

      - name: Deploy Web
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.web-taskdef.outputs.task-definition }}
          service: scr-web-production
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

  # ── Post-deploy ───────────────────────────────────────────────────────────────
  verify:
    name: Production verification
    runs-on: ubuntu-latest
    needs: [deploy]

    steps:
      - name: API health check
        run: |
          for i in {1..10}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ secrets.PROD_API_URL }}/health")
            if [ "$STATUS" = "200" ]; then
              echo "✓ API health check passed"
              exit 0
            fi
            echo "Attempt $i: HTTP $STATUS — waiting..."
            sleep 15
          done
          echo "❌ API health check failed"
          exit 1

      - name: Web health check
        run: |
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ secrets.PROD_WEB_URL }}/")
          echo "Web returned HTTP $STATUS"
          [[ "$STATUS" =~ ^(200|301|307)$ ]] || exit 1

      - name: Create GitHub release (on tag push)
        if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: context.ref.replace('refs/tags/', ''),
              name: `Release ${context.ref.replace('refs/tags/', '')}`,
              generate_release_notes: true,
              prerelease: false,
            });

      - name: Notify on failure
        if: failure()
        run: |
          echo "::error::Production deployment verification failed for ${{ env.IMAGE_TAG }}"
          # Add Slack/PagerDuty webhook here when configured
